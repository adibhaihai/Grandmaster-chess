<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>✨ Grandmaster Chess ♟️</title>
    <style>
        :root {
            --light-square: #f0d9b5;
            --dark-square: #b58863;
            --highlight: rgba(103, 146, 103, 0.6);
            --possible-move: rgba(103, 146, 103, 0.4);
            --check: rgba(255, 50, 50, 0.7);
            --win-color: #4CAF50;
            --lose-color: #F44336;
            --draw-color: #FFC107;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #e0eafc 0%, #cfdef3 100%);
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            color: #2c3e50;
        }
        
        .game-header {
            text-align: center;
            margin-bottom: 20px;
        }
        
        h1 {
            color: #4a4a4a;
            margin: 0;
            font-size: 2.5em;
            background: linear-gradient(135deg, #6e8efb, #a777e3);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }
        
        .subtitle {
            color: #7f8c8d;
            margin-top: 5px;
            font-style: italic;
        }
        
        .game-container {
            background-color: white;
            border-radius: 20px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.1);
            padding: 30px;
            width: 90%;
            max-width: 550px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }
        
        .game-container::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 10px;
            background: linear-gradient(90deg, #6e8efb, #a777e3);
        }
        
        .timer-container {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            background: #f8f9fa;
            padding: 10px 15px;
            border-radius: 10px;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.05);
        }
        
        .timer {
            font-family: 'Courier New', monospace;
            font-size: 1.2em;
            font-weight: bold;
            color: #2c3e50;
        }
        
        .player-turn {
            font-weight: bold;
            padding: 5px 10px;
            border-radius: 5px;
        }
        
        .white-turn {
            background-color: rgba(255, 255, 255, 0.7);
            border: 2px solid #b58863;
        }
        
        .black-turn {
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border: 2px solid #f0d9b5;
        }
        
        .chessboard {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            gap: 0;
            width: 100%;
            max-width: 400px;
            margin: 0 auto;
            border: 3px solid #555;
            border-radius: 5px;
            overflow: hidden;
            box-shadow: 0 10px 25px rgba(0,0,0,0.15);
            position: relative;
        }
        
        .square {
            aspect-ratio: 1/1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2em;
            cursor: pointer;
            position: relative;
            transition: all 0.2s;
            user-select: none;
        }
        
        .square:hover {
            transform: scale(1.05);
            z-index: 1;
            box-shadow: 0 0 15px rgba(0,0,0,0.2);
        }
        
        .light {
            background-color: var(--light-square);
        }
        
        .dark {
            background-color: var(--dark-square);
        }
        
        .selected {
            background-color: var(--highlight) !important;
        }
        
        .possible-move {
            position: relative;
        }
        
        .possible-move::after {
            content: "";
            position: absolute;
            width: 30%;
            height: 30%;
            background-color: var(--possible-move);
            border-radius: 50%;
        }
        
        .possible-capture {
            position: relative;
        }
        
        .possible-capture::before {
            content: "";
            position: absolute;
            width: 100%;
            height: 100%;
            border: 4px solid var(--possible-move);
            border-radius: 50%;
            box-sizing: border-box;
        }
        
        .in-check {
            background-color: var(--check) !important;
        }
        
        .controls {
            margin-top: 25px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
        }
        
        button {
            background: linear-gradient(135deg, #6e8efb, #a777e3);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: bold;
            transition: all 0.3s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 7px 14px rgba(0,0,0,0.15);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        .legend {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin-top: 20px;
            background: rgba(255,255,255,0.8);
            padding: 12px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.05);
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.9em;
        }
        
        .legend-emoji {
            font-size: 1.1em;
        }
        
        .status {
            margin-top: 15px;
            font-weight: bold;
            min-height: 22px;
            font-size: 1em;
            padding: 12px;
            border-radius: 8px;
            background-color: #f8f9fa;
            transition: all 0.3s ease;
        }
        
        .status.win {
            background-color: var(--win-color);
            color: white;
            font-size: 1.1em;
            padding: 15px;
            box-shadow: 0 4px 8px rgba(76, 175, 80, 0.3);
        }
        
        .status.lose {
            background-color: var(--lose-color);
            color: white;
            font-size: 1.1em;
            padding: 15px;
            box-shadow: 0 4px 8px rgba(244, 67, 54, 0.3);
        }
        
        .status.draw {
            background-color: var(--draw-color);
            color: #2c3e50;
            font-size: 1.1em;
            padding: 15px;
            box-shadow: 0 4px 8px rgba(255, 193, 7, 0.3);
        }
        
        .game-mode {
            margin-top: 12px;
            display: flex;
            justify-content: center;
            gap: 10px;
        }
        
        .game-mode button {
            background: linear-gradient(135deg, #4CAF50, #2E7D32);
        }
        
        .game-mode button.active {
            background: linear-gradient(135deg, #2E7D32, #1B5E20);
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.2);
        }
        
        .promotion-dialog {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0,0,0,0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        
        .promotion-options {
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            display: flex;
            gap: 10px;
        }
        
        .promotion-option {
            font-size: 2em;
            padding: 10px;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.2s;
        }
        
        .promotion-option:hover {
            background-color: #f0f0f0;
            transform: scale(1.1);
        }
        
        .tip {
            font-size: 0.85em;
            margin-top: 8px;
            font-style: italic;
            opacity: 0.9;
        }
        
        @media (max-width: 600px) {
            .square {
                font-size: 1.6em;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
            }
            
            .promotion-options {
                flex-direction: column;
            }
            
            .status {
                font-size: 0.9em;
                padding: 10px;
            }
            
            .status.win, .status.lose, .status.draw {
                font-size: 1em;
                padding: 12px;
            }
        }
    </style>
</head>
<body>
    <div class="game-header">
        <h1>✨ Grandmaster Chess ♟️</h1>
        <div class="subtitle">A beautiful game of strategy</div>
    </div>
    
    <div class="game-container">
        <div class="timer-container">
            <div class="timer">⏱️ <span id="game-time">00:00:00</span></div>
            <div class="player-turn white-turn" id="player-turn">White's turn</div>
        </div>
        
        <div class="chessboard" id="chessboard"></div>
        
        <div class="status" id="status"></div>
        
        <div class="game-mode">
            <button id="play-human" class="active">Play vs Human</button>
            <button id="play-computer">Play vs Computer</button>
            <button id="computer-color">Computer: Black</button>
        </div>
        
        <div class="controls">
            <button id="new-game">New Game</button>
            <button id="undo-move">Undo</button>
            <button id="flip-board">Flip Board</button>
        </div>
        
        <div class="legend">
            <div class="legend-item"><span class="legend-emoji">♔</span> 👑 King</div>
            <div class="legend-item"><span class="legend-emoji">♕</span> 👸 Queen</div>
            <div class="legend-item"><span class="legend-emoji">♖</span> 🏰 Rook</div>
            <div class="legend-item"><span class="legend-emoji">♗</span> 🎩 Bishop</div>
            <div class="legend-item"><span class="legend-emoji">♘</span> 🐴 Knight</div>
            <div class="legend-item"><span class="legend-emoji">♙</span> 💂 Pawn</div>
        </div>
    </div>

    <div id="promotion-dialog" class="promotion-dialog" style="display: none;">
        <div class="promotion-options" id="promotion-options"></div>
    </div>

    <script>
        // Game state
        let board = [];
        let selectedSquare = null;
        let possibleMoves = [];
        let currentPlayer = 'white';
        let gameActive = true;
        let startTime = null;
        let timerInterval = null;
        let boardFlipped = false;
        let vsComputer = false;
        let computerColor = 'black';
        let moveHistory = [];
        let enPassantTarget = null;
        let castlingRights = {
            white: { kingSide: true, queenSide: true },
            black: { kingSide: true, queenSide: true }
        };
        let halfMoveClock = 0; // For 50-move rule
        let fullMoveNumber = 1;
        let pendingPromotion = null;
        
        // Emoji pieces
        const pieces = {
            'white': {
                'king': '♔',
                'queen': '♕',
                'rook': '♖',
                'bishop': '♗',
                'knight': '♘',
                'pawn': '♙'
            },
            'black': {
                'king': '♚',
                'queen': '♛',
                'rook': '♜',
                'bishop': '♝',
                'knight': '♞',
                'pawn': '♟'
            }
        };
        
        // Piece values for computer AI
        const pieceValues = {
            'pawn': 1,
            'knight': 3,
            'bishop': 3,
            'rook': 5,
            'queen': 9,
            'king': 100
        };
        
        // Initialize the board
        function initBoard() {
            // Clear previous game
            clearInterval(timerInterval);
            document.getElementById('game-time').textContent = '00:00:00';
            startTime = null;
            moveHistory = [];
            enPassantTarget = null;
            castlingRights = {
                white: { kingSide: true, queenSide: true },
                black: { kingSide: true, queenSide: true }
            };
            halfMoveClock = 0;
            fullMoveNumber = 1;
            pendingPromotion = null;
            
            // Create initial board position
            board = Array(8).fill().map(() => Array(8).fill(null));
            
            // Set up pawns
            for (let i = 0; i < 8; i++) {
                board[1][i] = { type: 'pawn', color: 'black' };
                board[6][i] = { type: 'pawn', color: 'white' };
            }
            
            // Set up other pieces
            const backRow = ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'];
            for (let i = 0; i < 8; i++) {
                board[0][i] = { type: backRow[i], color: 'black' };
                board[7][i] = { type: backRow[i], color: 'white' };
            }
            
            currentPlayer = 'white';
            gameActive = true;
            selectedSquare = null;
            possibleMoves = [];
            updateStatus("");
            updatePlayerTurn();
            renderBoard();
            
            // If playing against computer and computer is white, make first move
            if (vsComputer && computerColor === 'white') {
                setTimeout(computerMove, 100);
            }
        }
        
        // Render the board
        function renderBoard() {
            const chessboard = document.getElementById('chessboard');
            chessboard.innerHTML = '';
            
            const rows = boardFlipped ? [7,6,5,4,3,2,1,0] : [0,1,2,3,4,5,6,7];
            const cols = boardFlipped ? [7,6,5,4,3,2,1,0] : [0,1,2,3,4,5,6,7];
            
            // Find king positions to check for check
            const whiteKingPos = findKing('white');
            const blackKingPos = findKing('black');
            const whiteInCheck = isSquareUnderAttack(whiteKingPos.row, whiteKingPos.col, 'black');
            const blackInCheck = isSquareUnderAttack(blackKingPos.row, blackKingPos.col, 'white');
            
            for (let r = 0; r < 8; r++) {
                const row = rows[r];
                for (let c = 0; c < 8; c++) {
                    const col = cols[c];
                    const square = document.createElement('div');
                    const isLight = (row + col) % 2 === 0;
                    square.className = `square ${isLight ? 'light' : 'dark'}`;
                    square.dataset.row = row;
                    square.dataset.col = col;
                    
                    // Highlight selected square
                    if (selectedSquare && selectedSquare.row === row && selectedSquare.col === col) {
                        square.classList.add('selected');
                    }
                    
                    // Highlight possible moves
                    const isPossibleMove = possibleMoves.some(move => move.row === row && move.col === col);
                    if (isPossibleMove) {
                        if (board[row][col]) {
                            square.classList.add('possible-capture');
                        } else {
                            square.classList.add('possible-move');
                        }
                    }
                    
                    // Highlight king in check
                    if ((currentPlayer === 'white' && whiteInCheck && row === whiteKingPos.row && col === whiteKingPos.col) ||
                        (currentPlayer === 'black' && blackInCheck && row === blackKingPos.row && col === blackKingPos.col)) {
                        square.classList.add('in-check');
                    }
                    
                    // Add piece if present
                    const piece = board[row][col];
                    if (piece) {
                        square.textContent = pieces[piece.color][piece.type];
                        square.style.cursor = 'pointer';
                        square.style.textShadow = `1px 1px 2px rgba(0,0,0,${piece.color === 'white' ? '0.3' : '0.5'})`;
                    }
                    
                    square.addEventListener('click', () => handleSquareClick(row, col));
                    chessboard.appendChild(square);
                }
            }
        }
        
        // Find king position
        function findKing(color) {
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (board[row][col] && board[row][col].type === 'king' && board[row][col].color === color) {
                        return { row, col };
                    }
                }
            }
            return { row: -1, col: -1 }; // Should never happen
        }
        
        // Handle square clicks
        function handleSquareClick(row, col) {
            if (!gameActive || (vsComputer && currentPlayer === computerColor)) return;
            if (pendingPromotion) return;
            
            const piece = board[row][col];
            
            // If no square is selected and the clicked square has a piece of the current player's color
            if (!selectedSquare && piece && piece.color === currentPlayer) {
                selectedSquare = { row, col };
                possibleMoves = getPossibleMoves(row, col).filter(move => {
                    // Filter out moves that would leave king in check
                    const testBoard = cloneBoard();
                    testBoard[move.row][move.col] = testBoard[row][col];
                    testBoard[row][col] = null;
                    
                    // Handle special cases
                    if (piece.type === 'king' && Math.abs(move.col - col) === 2) {
                        // Castling move - move rook too
                        const rookCol = move.col > col ? 7 : 0;
                        const newRookCol = move.col > col ? 5 : 3;
                        testBoard[move.row][newRookCol] = testBoard[move.row][rookCol];
                        testBoard[move.row][rookCol] = null;
                    } else if (piece.type === 'pawn' && move.col !== col && !testBoard[move.row][move.col]) {
                        // En passant capture - remove the captured pawn
                        testBoard[row][move.col] = null;
                    }
                    
                    const kingPos = findKing(currentPlayer);
                    return !isSquareUnderAttack(kingPos.row, kingPos.col, currentPlayer === 'white' ? 'black' : 'white', testBoard);
                });
                renderBoard();
            }
            // If a square is already selected
            else if (selectedSquare) {
                // If clicking on another piece of the same color, select that piece instead
                if (piece && piece.color === currentPlayer) {
                    selectedSquare = { row, col };
                    possibleMoves = getPossibleMoves(row, col).filter(move => {
                        // Filter out moves that would leave king in check
                        const testBoard = cloneBoard();
                        testBoard[move.row][move.col] = testBoard[row][col];
                        testBoard[row][col] = null;
                        
                        // Handle special cases
                        if (piece.type === 'king' && Math.abs(move.col - col) === 2) {
                            // Castling move - move rook too
                            const rookCol = move.col > col ? 7 : 0;
                            const newRookCol = move.col > col ? 5 : 3;
                            testBoard[move.row][newRookCol] = testBoard[move.row][rookCol];
                            testBoard[move.row][rookCol] = null;
                        } else if (piece.type === 'pawn' && move.col !== col && !testBoard[move.row][move.col]) {
                            // En passant capture - remove the captured pawn
                            testBoard[row][move.col] = null;
                        }
                        
                        const kingPos = findKing(currentPlayer);
                        return !isSquareUnderAttack(kingPos.row, kingPos.col, currentPlayer === 'white' ? 'black' : 'white', testBoard);
                    });
                    renderBoard();
                }
                // If the move is valid, make the move
                else if (isValidMove(selectedSquare.row, selectedSquare.col, row, col)) {
                    makeMove(selectedSquare.row, selectedSquare.col, row, col);
                    selectedSquare = null;
                    possibleMoves = [];
                    renderBoard();
                    
                    // If playing against computer and it's computer's turn, make computer move
                    if (vsComputer && gameActive && currentPlayer === computerColor) {
                        setTimeout(computerMove, 300); // Small delay for better UX
                    }
                }
                // Otherwise, deselect
                else {
                    selectedSquare = null;
                    possibleMoves = [];
                    renderBoard();
                }
            }
        }
        
        // Get possible moves for a piece
        function getPossibleMoves(row, col) {
            const piece = board[row][col];
            if (!piece) return [];
            
            const moves = [];
            
            // Pawn moves
            if (piece.type === 'pawn') {
                const direction = piece.color === 'white' ? -1 : 1;
                const startRow = piece.color === 'white' ? 6 : 1;
                
                // Forward move
                if (isInBounds(row + direction, col) && !board[row + direction][col]) {
                    moves.push({ row: row + direction, col });
                    
                    // Double move from starting position
                    if (row === startRow && !board[row + 2 * direction][col] && !board[row + direction][col]) {
                        moves.push({ row: row + 2 * direction, col });
                    }
                }
                
                // Captures
                for (const colOffset of [-1, 1]) {
                    const newCol = col + colOffset;
                    if (isInBounds(row + direction, newCol)) {
                        if (board[row + direction][newCol] && board[row + direction][newCol].color !== piece.color) {
                            moves.push({ row: row + direction, col: newCol });
                        }
                        // En passant
                        else if (enPassantTarget && enPassantTarget.row === row + direction && enPassantTarget.col === newCol) {
                            moves.push({ row: row + direction, col: newCol });
                        }
                    }
                }
            }
            // Rook moves
            else if (piece.type === 'rook') {
                const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                addSlidingMoves(row, col, directions, moves, piece.color);
            }
            // Knight moves
            else if (piece.type === 'knight') {
                const movesRelative = [
                    [-2, -1], [-2, 1], [-1, -2], [-1, 2],
                    [1, -2], [1, 2], [2, -1], [2, 1]
                ];
                addJumpMoves(row, col, movesRelative, moves, piece.color);
            }
            // Bishop moves
            else if (piece.type === 'bishop') {
                const directions = [[-1, -1], [-1, 1], [1, -1], [1, 1]];
                addSlidingMoves(row, col, directions, moves, piece.color);
            }
            // Queen moves
            else if (piece.type === 'queen') {
                const directions = [
                    [-1, 0], [1, 0], [0, -1], [0, 1],
                    [-1, -1], [-1, 1], [1, -1], [1, 1]
                ];
                addSlidingMoves(row, col, directions, moves, piece.color);
            }
            // King moves
            else if (piece.type === 'king') {
                for (let dr = -1; dr <= 1; dr++) {
                    for (let dc = -1; dc <= 1; dc++) {
                        if (dr === 0 && dc === 0) continue;
                        const newRow = row + dr;
                        const newCol = col + dc;
                        if (isInBounds(newRow, newCol)) {
                            if (!board[newRow][newCol] || board[newRow][newCol].color !== piece.color) {
                                moves.push({ row: newRow, col: newCol });
                            }
                        }
                    }
                }
                
                // Castling
                if (piece.color === 'white') {
                    if (castlingRights.white.kingSide && 
                        !board[7][5] && !board[7][6] &&
                        !isSquareUnderAttack(7, 4, 'black') &&
                        !isSquareUnderAttack(7, 5, 'black') &&
                        !isSquareUnderAttack(7, 6, 'black')) {
                        moves.push({ row: 7, col: 6 }); // Kingside
                    }
                    if (castlingRights.white.queenSide && 
                        !board[7][3] && !board[7][2] && !board[7][1] &&
                        !isSquareUnderAttack(7, 4, 'black') &&
                        !isSquareUnderAttack(7, 3, 'black') &&
                        !isSquareUnderAttack(7, 2, 'black')) {
                        moves.push({ row: 7, col: 2 }); // Queenside
                    }
                } else {
                    if (castlingRights.black.kingSide && 
                        !board[0][5] && !board[0][6] &&
                        !isSquareUnderAttack(0, 4, 'white') &&
                        !isSquareUnderAttack(0, 5, 'white') &&
                        !isSquareUnderAttack(0, 6, 'white')) {
                        moves.push({ row: 0, col: 6 }); // Kingside
                    }
                    if (castlingRights.black.queenSide && 
                        !board[0][3] && !board[0][2] && !board[0][1] &&
                        !isSquareUnderAttack(0, 4, 'white') &&
                        !isSquareUnderAttack(0, 3, 'white') &&
                        !isSquareUnderAttack(0, 2, 'white')) {
                        moves.push({ row: 0, col: 2 }); // Queenside
                    }
                }
            }
            
            return moves;
        }
        
        // Helper function for sliding pieces
        function addSlidingMoves(row, col, directions, moves, color) {
            for (const [dr, dc] of directions) {
                for (let i = 1; i < 8; i++) {
                    const newRow = row + i * dr;
                    const newCol = col + i * dc;
                    if (!isInBounds(newRow, newCol)) break;
                    
                    if (!board[newRow][newCol]) {
                        moves.push({ row: newRow, col: newCol });
                    } else {
                        if (board[newRow][newCol].color !== color) {
                            moves.push({ row: newRow, col: newCol });
                        }
                        break;
                    }
                }
            }
        }
        
        // Helper function for jumping pieces
        function addJumpMoves(row, col, movesRelative, moves, color) {
            for (const [dr, dc] of movesRelative) {
                const newRow = row + dr;
                const newCol = col + dc;
                if (isInBounds(newRow, newCol) && 
                    (!board[newRow][newCol] || board[newRow][newCol].color !== color)) {
                    moves.push({ row: newRow, col: newCol });
                }
            }
        }
        
        // Check if a move is valid
        function isValidMove(fromRow, fromCol, toRow, toCol) {
            return possibleMoves.some(move => move.row === toRow && move.col === toCol);
        }
        
        // Make a move
        function makeMove(fromRow, fromCol, toRow, toCol) {
            if (!gameActive) return;
            
            // Start timer on first move
            if (startTime === null) {
                startTime = new Date();
                timerInterval = setInterval(updateTimer, 1000);
            }
            
            const piece = board[fromRow][fromCol];
            const capturedPiece = board[toRow][toCol];
            
            // Store move in history for undo
            moveHistory.push({
                from: { row: fromRow, col: fromCol },
                to: { row: toRow, col: toCol },
                piece: { ...piece },
                captured: capturedPiece ? { ...capturedPiece } : null,
                promoted: false,
                castling: null,
                enPassant: false,
                castlingRights: JSON.parse(JSON.stringify(castlingRights)),
                enPassantTarget: enPassantTarget,
                halfMoveClock: halfMoveClock,
                fullMoveNumber: fullMoveNumber
            });
            
            // Move the piece
            board[toRow][toCol] = piece;
            board[fromRow][fromCol] = null;
            
            // Handle special moves
            let promotionPiece = null;
            
            // En passant capture
            if (piece.type === 'pawn' && toCol !== fromCol && !capturedPiece) {
                board[fromRow][toCol] = null; // Remove the captured pawn
                moveHistory[moveHistory.length - 1].enPassant = true;
            }
            
            // Pawn promotion
            if (piece.type === 'pawn' && (toRow === 0 || toRow === 7)) {
                if (vsComputer && currentPlayer === computerColor) {
                    // Computer always promotes to queen
                    board[toRow][toCol].type = 'queen';
                    moveHistory[moveHistory.length - 1].promoted = true;
                } else {
                    // Show promotion dialog for human player
                    pendingPromotion = { row: toRow, col: toCol };
                    showPromotionDialog(piece.color);
                    return; // Wait for promotion selection
                }
            }
            
            // Castling - move the rook
            if (piece.type === 'king' && Math.abs(toCol - fromCol) === 2) {
                const rookCol = toCol > fromCol ? 7 : 0;
                const newRookCol = toCol > fromCol ? 5 : 3;
                board[toRow][newRookCol] = board[toRow][rookCol];
                board[toRow][rookCol] = null;
                moveHistory[moveHistory.length - 1].castling = toCol > fromCol ? 'kingSide' : 'queenSide';
            }
            
            // Update castling rights
            if (piece.type === 'king') {
                if (piece.color === 'white') {
                    castlingRights.white.kingSide = false;
                    castlingRights.white.queenSide = false;
                } else {
                    castlingRights.black.kingSide = false;
                    castlingRights.black.queenSide = false;
                }
            } else if (piece.type === 'rook') {
                if (piece.color === 'white') {
                    if (fromRow === 7 && fromCol === 0) castlingRights.white.queenSide = false;
                    if (fromRow === 7 && fromCol === 7) castlingRights.white.kingSide = false;
                } else {
                    if (fromRow === 0 && fromCol === 0) castlingRights.black.queenSide = false;
                    if (fromRow === 0 && fromCol === 7) castlingRights.black.kingSide = false;
                }
            }
            
            // Set en passant target
            enPassantTarget = null;
            if (piece.type === 'pawn' && Math.abs(toRow - fromRow) === 2) {
                enPassantTarget = { row: fromRow + (toRow - fromRow) / 2, col: fromCol };
            }
            
            // Update move counters
            if (piece.type === 'pawn' || capturedPiece) {
                halfMoveClock = 0;
            } else {
                halfMoveClock++;
            }
            
            if (currentPlayer === 'black') {
                fullMoveNumber++;
            }
            
            // Check for 50-move rule
            if (halfMoveClock >= 50) {
                gameActive = false;
                updateStatus("Game drawn by 50-move rule", "draw");
                clearInterval(timerInterval);
                return;
            }
            
            // Switch players
            currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
            updatePlayerTurn();
            
            // Check for checkmate or stalemate
            if (isCheckmate()) {
                gameActive = false;
                const winner = currentPlayer === 'white' ? 'Black' : 'White';
                const isPlayerWin = (winner === 'White' && computerColor === 'black') || (winner === 'Black' && computerColor === 'white');
                
                if (isPlayerWin) {
                    updateStatus("🎉 Congratulations! You won by checkmate!", "win");
                } else {
                    updateStatus("💀 You lost by checkmate! Try controlling the center more next time.", "lose");
                }
                clearInterval(timerInterval);
            } else if (isStalemate()) {
                gameActive = false;
                updateStatus("Game drawn by stalemate", "draw");
                clearInterval(timerInterval);
            } else {
                // Check for check
                const kingPos = findKing(currentPlayer);
                if (isSquareUnderAttack(kingPos.row, kingPos.col, currentPlayer === 'white' ? 'black' : 'white')) {
                    updateStatus(`${currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1)} is in check!`);
                } else {
                    updateStatus("");
                }
            }
            
            renderBoard();
        }
        
        // Complete pawn promotion
        function completePromotion(pieceType) {
            if (!pendingPromotion) return;
            
            const { row, col } = pendingPromotion;
            board[row][col].type = pieceType;
            moveHistory[moveHistory.length - 1].promoted = true;
            pendingPromotion = null;
            
            document.getElementById('promotion-dialog').style.display = 'none';
            
            // Switch players
            currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
            updatePlayerTurn();
            
            // Check for checkmate or stalemate
            if (isCheckmate()) {
                gameActive = false;
                const winner = currentPlayer === 'white' ? 'Black' : 'White';
                const isPlayerWin = (winner === 'White' && computerColor === 'black') || (winner === 'Black' && computerColor === 'white');
                
                if (isPlayerWin) {
                    updateStatus("🎉 Congratulations! You won by checkmate!", "win");
                } else {
                    updateStatus("💀 You lost by checkmate! Try controlling the center more next time.", "lose");
                }
                clearInterval(timerInterval);
            } else if (isStalemate()) {
                gameActive = false;
                updateStatus("Game drawn by stalemate", "draw");
                clearInterval(timerInterval);
            }
            
            renderBoard();
            
            // If playing against computer and it's computer's turn, make computer move
            if (vsComputer && gameActive && currentPlayer === computerColor) {
                setTimeout(computerMove, 300);
            }
        }
        
        // Show promotion dialog
        function showPromotionDialog(color) {
            const dialog = document.getElementById('promotion-dialog');
            const options = document.getElementById('promotion-options');
            options.innerHTML = '';
            
            const pieceTypes = ['queen', 'rook', 'bishop', 'knight'];
            for (const type of pieceTypes) {
                const option = document.createElement('div');
                option.className = 'promotion-option';
                option.textContent = pieces[color][type];
                option.addEventListener('click', () => completePromotion(type));
                options.appendChild(option);
            }
            
            dialog.style.display = 'flex';
        }
        
        // Undo the last move
        function undoMove() {
            if (moveHistory.length === 0 || !gameActive) return;
            
            const lastMove = moveHistory.pop();
            
            // Restore the moved piece
            board[lastMove.from.row][lastMove.from.col] = lastMove.piece;
            
            // Restore captured piece or clear the square
            if (lastMove.captured) {
                board[lastMove.to.row][lastMove.to.col] = lastMove.captured;
            } else {
                board[lastMove.to.row][lastMove.to.col] = null;
            }
            
            // If the move was a promotion, revert the piece type
            if (lastMove.promoted) {
                board[lastMove.from.row][lastMove.from.col].type = 'pawn';
            }
            
            // Restore castling rights
            castlingRights = lastMove.castlingRights;
            
            // Restore en passant target
            enPassantTarget = lastMove.enPassantTarget;
            
            // Restore move counters
            halfMoveClock = lastMove.halfMoveClock;
            fullMoveNumber = lastMove.fullMoveNumber;
            
            // If the move was castling, move the rook back
            if (lastMove.castling) {
                const rookCol = lastMove.castling === 'kingSide' ? 7 : 0;
                const newRookCol = lastMove.castling === 'kingSide' ? 5 : 3;
                board[lastMove.from.row][rookCol] = board[lastMove.from.row][newRookCol];
                board[lastMove.from.row][newRookCol] = null;
            }
            
            // If the move was en passant, restore the captured pawn
            if (lastMove.enPassant) {
                const direction = lastMove.piece.color === 'white' ? 1 : -1;
                board[lastMove.to.row + direction][lastMove.to.col] = { type: 'pawn', color: lastMove.piece.color === 'white' ? 'black' : 'white' };
            }
            
            // Switch back to the previous player
            currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
            updatePlayerTurn();
            
            // Clear selection and possible moves
            selectedSquare = null;
            possibleMoves = [];
            
            // If playing against computer and we're undoing the computer's move,
            // we need to undo the player's previous move as well
            if (vsComputer && currentPlayer === computerColor && moveHistory.length > 0) {
                undoMove();
            }
            
            renderBoard();
            updateStatus("Move undone");
        }
        
        // Check if coordinates are within bounds
        function isInBounds(row, col) {
            return row >= 0 && row < 8 && col >= 0 && col < 8;
        }
        
        // Check if a square is under attack
        function isSquareUnderAttack(row, col, byColor, customBoard = null) {
            const boardToCheck = customBoard || board;
            
            // Check for pawn attacks
            const pawnDirection = byColor === 'white' ? -1 : 1;
            for (const colOffset of [-1, 1]) {
                const pawnRow = row - pawnDirection;
                const pawnCol = col + colOffset;
                if (isInBounds(pawnRow, pawnCol)) {
                    const piece = boardToCheck[pawnRow][pawnCol];
                    if (piece && piece.type === 'pawn' && piece.color === byColor) {
                        return true;
                    }
                }
            }
            
            // Check for knight attacks
            const knightMoves = [
                [-2, -1], [-2, 1], [-1, -2], [-1, 2],
                [1, -2], [1, 2], [2, -1], [2, 1]
            ];
            for (const [dr, dc] of knightMoves) {
                const knightRow = row + dr;
                const knightCol = col + dc;
                if (isInBounds(knightRow, knightCol)) {
                    const piece = boardToCheck[knightRow][knightCol];
                    if (piece && piece.type === 'knight' && piece.color === byColor) {
                        return true;
                    }
                }
            }
            
            // Check for king attacks (adjacent squares)
            for (let dr = -1; dr <= 1; dr++) {
                for (let dc = -1; dc <= 1; dc++) {
                    if (dr === 0 && dc === 0) continue;
                    const kingRow = row + dr;
                    const kingCol = col + dc;
                    if (isInBounds(kingRow, kingCol)) {
                        const piece = boardToCheck[kingRow][kingCol];
                        if (piece && piece.type === 'king' && piece.color === byColor) {
                            return true;
                        }
                    }
                }
            }
            
            // Check for rook/queen attacks (straight lines)
            const straightDirections = [[-1, 0], [1, 0], [0, -1], [0, 1]];
            for (const [dr, dc] of straightDirections) {
                for (let i = 1; i < 8; i++) {
                    const attackRow = row + i * dr;
                    const attackCol = col + i * dc;
                    if (!isInBounds(attackRow, attackCol)) break;
                    
                    const piece = boardToCheck[attackRow][attackCol];
                    if (piece) {
                        if (piece.color === byColor && 
                            (piece.type === 'rook' || piece.type === 'queen')) {
                            return true;
                        }
                        break;
                    }
                }
            }
            
            // Check for bishop/queen attacks (diagonals)
            const diagonalDirections = [[-1, -1], [-1, 1], [1, -1], [1, 1]];
            for (const [dr, dc] of diagonalDirections) {
                for (let i = 1; i < 8; i++) {
                    const attackRow = row + i * dr;
                    const attackCol = col + i * dc;
                    if (!isInBounds(attackRow, attackCol)) break;
                    
                    const piece = boardToCheck[attackRow][attackCol];
                    if (piece) {
                        if (piece.color === byColor && 
                            (piece.type === 'bishop' || piece.type === 'queen')) {
                            return true;
                        }
                        break;
                    }
                }
            }
            
            return false;
        }
        
        // Check for checkmate
        function isCheckmate() {
            // First check if king is in check
            const kingPos = findKing(currentPlayer);
            const inCheck = isSquareUnderAttack(kingPos.row, kingPos.col, currentPlayer === 'white' ? 'black' : 'white');
            
            if (!inCheck) return false;
            
            // Check if any move can get out of check
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece && piece.color === currentPlayer) {
                        const moves = getPossibleMoves(row, col);
                        for (const move of moves) {
                            const testBoard = cloneBoard();
                            testBoard[move.row][move.col] = testBoard[row][col];
                            testBoard[row][col] = null;
                            
                            // Handle special cases
                            if (piece.type === 'king' && Math.abs(move.col - col) === 2) {
                                // Castling move - move rook too
                                const rookCol = move.col > col ? 7 : 0;
                                const newRookCol = move.col > col ? 5 : 3;
                                testBoard[move.row][newRookCol] = testBoard[move.row][rookCol];
                                testBoard[move.row][rookCol] = null;
                            } else if (piece.type === 'pawn' && move.col !== col && !testBoard[move.row][move.col]) {
                                // En passant capture - remove the captured pawn
                                testBoard[row][move.col] = null;
                            }
                            
                            const testKingPos = findKing(currentPlayer, testBoard);
                            if (!isSquareUnderAttack(testKingPos.row, testKingPos.col, currentPlayer === 'white' ? 'black' : 'white', testBoard)) {
                                return false; // Found a move that gets out of check
                            }
                        }
                    }
                }
            }
            
            return true; // No moves get out of check
        }
        
        // Check for stalemate
        function isStalemate() {
            // King is not in check
            const kingPos = findKing(currentPlayer);
            const inCheck = isSquareUnderAttack(kingPos.row, kingPos.col, currentPlayer === 'white' ? 'black' : 'white');
            if (inCheck) return false;
            
            // Check if any legal move is available
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece && piece.color === currentPlayer) {
                        const moves = getPossibleMoves(row, col).filter(move => {
                            // Filter out moves that would leave king in check
                            const testBoard = cloneBoard();
                            testBoard[move.row][move.col] = testBoard[row][col];
                            testBoard[row][col] = null;
                            
                            // Handle special cases
                            if (piece.type === 'king' && Math.abs(move.col - col) === 2) {
                                // Castling move - move rook too
                                const rookCol = move.col > col ? 7 : 0;
                                const newRookCol = move.col > col ? 5 : 3;
                                testBoard[move.row][newRookCol] = testBoard[move.row][rookCol];
                                testBoard[move.row][rookCol] = null;
                            } else if (piece.type === 'pawn' && move.col !== col && !testBoard[move.row][move.col]) {
                                // En passant capture - remove the captured pawn
                                testBoard[row][move.col] = null;
                            }
                            
                            const testKingPos = findKing(currentPlayer, testBoard);
                            return !isSquareUnderAttack(testKingPos.row, testKingPos.col, currentPlayer === 'white' ? 'black' : 'white', testBoard);
                        });
                        
                        if (moves.length > 0) {
                            return false; // Found a legal move
                        }
                    }
                }
            }
            
            return true; // No legal moves available
        }
        
        // Find king position (with optional custom board)
        function findKing(color, customBoard = null) {
            const boardToCheck = customBoard || board;
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (boardToCheck[row][col] && boardToCheck[row][col].type === 'king' && boardToCheck[row][col].color === color) {
                        return { row, col };
                    }
                }
            }
            return { row: -1, col: -1 }; // Should never happen
        }
        
        // Create a deep copy of the board
        function cloneBoard() {
            return board.map(row => row.map(cell => cell ? {...cell} : null));
        }
        
        // Computer makes a move
        function computerMove() {
            if (!gameActive || currentPlayer !== computerColor) return;
            
            // Find all possible moves for computer
            const allMoves = [];
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece && piece.color === computerColor) {
                        const moves = getPossibleMoves(row, col);
                        for (const move of moves) {
                            allMoves.push({
                                from: { row, col },
                                to: move,
                                piece: piece.type
                            });
                        }
                    }
                }
            }
            
            if (allMoves.length === 0) {
                // No moves available - checkmate or stalemate
                gameActive = false;
                if (isCheckmate()) {
                    const winner = currentPlayer === 'white' ? 'Black' : 'White';
                    const isPlayerWin = (winner === 'White' && computerColor === 'black') || (winner === 'Black' && computerColor === 'white');
                    
                    if (isPlayerWin) {
                        updateStatus("🎉 Congratulations! You won by checkmate!", "win");
                    } else {
                        updateStatus("💀 You lost by checkmate! Try controlling the center more next time.", "lose");
                    }
                } else {
                    updateStatus("Game ended in stalemate!", "draw");
                }
                clearInterval(timerInterval);
                return;
            }
            
            // Evaluate moves and pick one
            const bestMove = findBestMove(allMoves);
            
            // Make the move
            makeMove(bestMove.from.row, bestMove.from.col, bestMove.to.row, bestMove.to.col);
            renderBoard();
        }
        
        // Improved AI to find the best move
        function findBestMove(moves) {
            // First, look for checkmate in one move
            for (const move of moves) {
                const testBoard = cloneBoard();
                testBoard[move.to.row][move.to.col] = testBoard[move.from.row][move.from.col];
                testBoard[move.from.row][move.from.col] = null;
                
                // Handle special cases
                if (move.piece === 'king' && Math.abs(move.to.col - move.from.col) === 2) {
                    // Castling move - move rook too
                    const rookCol = move.to.col > move.from.col ? 7 : 0;
                    const newRookCol = move.to.col > move.from.col ? 5 : 3;
                    testBoard[move.to.row][newRookCol] = testBoard[move.to.row][rookCol];
                    testBoard[move.to.row][rookCol] = null;
                } else if (move.piece === 'pawn' && move.to.col !== move.from.col && !testBoard[move.to.row][move.to.col]) {
                    // En passant capture - remove the captured pawn
                    testBoard[move.from.row][move.to.col] = null;
                }
                
                const opponentColor = computerColor === 'white' ? 'black' : 'white';
                const opponentKingPos = findKing(opponentColor, testBoard);
                if (isSquareUnderAttack(opponentKingPos.row, opponentKingPos.col, computerColor, testBoard)) {
                    // This move puts opponent in check - is it checkmate?
                    const tempCurrentPlayer = currentPlayer;
                    currentPlayer = opponentColor;
                    const isMate = isCheckmateForBoard(testBoard, opponentColor);
                    currentPlayer = tempCurrentPlayer;
                    
                    if (isMate) {
                        return move; // Found checkmate!
                    }
                }
            }
            
            // Then look for capturing opponent's queen
            let queenCapture = null;
            for (const move of moves) {
                const targetPiece = board[move.to.row][move.to.col];
                if (targetPiece && targetPiece.type === 'queen') {
                    queenCapture = move;
                    break;
                }
            }
            if (queenCapture) return queenCapture;
            
            // Then look for capturing moves with highest value
            let bestCapture = null;
            let bestCaptureValue = -1;
            
            // Also evaluate positional advantage
            let bestScore = -Infinity;
            let bestMove = moves[0]; // Default to first move if no better found
            
            for (const move of moves) {
                const targetPiece = board[move.to.row][move.to.col];
                let score = 0;
                
                // Material advantage
                if (targetPiece) {
                    score += pieceValues[targetPiece.type] * 1.5; // Prefer captures
                }
                
                // Center control bonus
                if ((move.to.row === 3 || move.to.row === 4) && (move.to.col === 3 || move.to.col === 4)) {
                    score += 0.5;
                }
                
                // Development bonus for minor pieces
                if ((move.piece === 'knight' || move.piece === 'bishop') && 
                    (move.from.row === (computerColor === 'white' ? 7 : 0))) {
                    score += 0.3;
                }
                
                // King safety (avoid moving king unless necessary)
                if (move.piece === 'king') {
                    score -= 0.5;
                }
                
                // Pawn advancement (for endgame)
                if (move.piece === 'pawn') {
                    const advancement = computerColor === 'white' ? 7 - move.to.row : move.to.row;
                    score += advancement * 0.1;
                }
                
                // Check if this move puts opponent in check
                const testBoard = cloneBoard();
                testBoard[move.to.row][move.to.col] = testBoard[move.from.row][move.from.col];
                testBoard[move.from.row][move.from.col] = null;
                
                // Handle special cases
                if (move.piece === 'king' && Math.abs(move.to.col - move.from.col) === 2) {
                    // Castling move - move rook too
                    const rookCol = move.to.col > move.from.col ? 7 : 0;
                    const newRookCol = move.to.col > move.from.col ? 5 : 3;
                    testBoard[move.to.row][newRookCol] = testBoard[move.to.row][rookCol];
                    testBoard[move.to.row][rookCol] = null;
                } else if (move.piece === 'pawn' && move.to.col !== move.from.col && !testBoard[move.to.row][move.to.col]) {
                    // En passant capture - remove the captured pawn
                    testBoard[move.from.row][move.to.col] = null;
                }
                
                const opponentColor = computerColor === 'white' ? 'black' : 'white';
                const opponentKingPos = findKing(opponentColor, testBoard);
                if (isSquareUnderAttack(opponentKingPos.row, opponentKingPos.col, computerColor, testBoard)) {
                    score += 0.8; // Bonus for checks
                }
                
                // Penalize moves that leave pieces undefended
                if (!targetPiece && isSquareUnderAttack(move.to.row, move.to.col, opponentColor, testBoard)) {
                    score -= pieceValues[move.piece] * 0.7;
                }
                
                // If this move is better than previous best, take it
                if (score > bestScore || (score === bestScore && Math.random() > 0.7)) {
                    bestScore = score;
                    bestMove = move;
                }
                
                // Also track best capture separately
                if (targetPiece) {
                    const captureValue = pieceValues[targetPiece.type];
                    
                    // Bonus for capturing with less valuable piece
                    const valueDifference = captureValue - pieceValues[move.piece];
                    
                    if (valueDifference > bestCaptureValue || 
                        (valueDifference === bestCaptureValue && Math.random() > 0.5)) {
                        bestCaptureValue = valueDifference;
                        bestCapture = move;
                    }
                }
            }
            
            // If we have a good capture (winning material), prefer that over positional moves
            if (bestCapture && bestCaptureValue >= 1) {
                return bestCapture;
            }
            
            return bestMove;
        }
        
        // Check for checkmate on a given board state
        function isCheckmateForBoard(testBoard, playerToCheck) {
            // First check if king is in check
            const kingPos = findKing(playerToCheck, testBoard);
            const inCheck = isSquareUnderAttack(kingPos.row, kingPos.col, 
                playerToCheck === 'white' ? 'black' : 'white', testBoard);
            
            if (!inCheck) return false;
            
            // Check if any move can get out of check
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = testBoard[row][col];
                    if (piece && piece.color === playerToCheck) {
                        // Get possible moves for this piece (simplified version)
                        const moves = [];
                        if (piece.type === 'king') {
                            for (let dr = -1; dr <= 1; dr++) {
                                for (let dc = -1; dc <= 1; dc++) {
                                    if (dr === 0 && dc === 0) continue;
                                    const newRow = row + dr;
                                    const newCol = col + dc;
                                    if (isInBounds(newRow, newCol)) {
                                        if (!testBoard[newRow][newCol] || testBoard[newRow][newCol].color !== piece.color) {
                                            moves.push({ row: newRow, col: newCol });
                                        }
                                    }
                                }
                            }
                        } else {
                            // For other pieces, just check if they can block or capture
                            // This is simplified - a real implementation would need full move generation
                            continue;
                        }
                        
                        for (const move of moves) {
                            const tempBoard = cloneBoard(testBoard);
                            tempBoard[move.row][move.col] = tempBoard[row][col];
                            tempBoard[row][col] = null;
                            
                            const tempKingPos = findKing(playerToCheck, tempBoard);
                            if (!isSquareUnderAttack(tempKingPos.row, tempKingPos.col, 
                                playerToCheck === 'white' ? 'black' : 'white', tempBoard)) {
                                return false; // Found a move that gets out of check
                            }
                        }
                    }
                }
            }
            
            return true; // No moves get out of check
        }
        
        // Update game status with styling
        function updateStatus(message, type = "") {
            const statusElement = document.getElementById('status');
            statusElement.textContent = message;
            
            // Remove all classes
            statusElement.className = 'status';
            
            // Add specific class if provided
            if (type) {
                statusElement.classList.add(type);
                
                // Add tips for the player
                if (type === 'lose') {
                    const tip = document.createElement('div');
                    tip.className = 'tip';
                    tip.textContent = getRandomLosingTip();
                    statusElement.appendChild(tip);
                } else if (type === 'win') {
                    const tip = document.createElement('div');
                    tip.className = 'tip';
                    tip.textContent = getRandomWinningTip();
                    statusElement.appendChild(tip);
                }
            }
        }
        
        // Get random tip for losing player
        function getRandomLosingTip() {
            const tips = [
                "Tip: Control the center of the board with your pawns and pieces.",
                "Tip: Develop your knights and bishops early in the game.",
                "Tip: Castle early to protect your king.",
                "Tip: Look for forks and pins to win material.",
                "Tip: Don't move the same piece multiple times in the opening.",
                "Tip: Keep your pieces protected and coordinated.",
                "Tip: Pay attention to your opponent's threats.",
                "Tip: Trade pieces when you're ahead in material."
            ];
            return tips[Math.floor(Math.random() * tips.length)];
        }
        
        // Get random tip for winning player
        function getRandomWinningTip() {
            const tips = [
                "Well played! Try controlling the center even more next game.",
                "Great job! Now try to develop your pieces faster in the opening.",
                "Excellent! Next time, try to castle by move 10.",
                "Nice win! Look for opportunities to create passed pawns.",
                "Good game! Practice spotting forks and skewers.",
                "Well done! Try to anticipate your opponent's plans next game.",
                "Victory! Work on converting material advantages into wins.",
                "Success! Next game, focus on piece coordination."
            ];
            return tips[Math.floor(Math.random() * tips.length)];
        }
        
        // Update player turn display
        function updatePlayerTurn() {
            const turnElement = document.getElementById('player-turn');
            turnElement.textContent = `${currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1)}'s turn`;
            turnElement.className = `player-turn ${currentPlayer}-turn`;
        }
        
        // Update game timer
        function updateTimer() {
            if (!startTime) return;
            
            const now = new Date();
            const elapsed = Math.floor((now - startTime) / 1000);
            
            const hours = Math.floor(elapsed / 3600);
            const minutes = Math.floor((elapsed % 3600) / 60);
            const seconds = elapsed % 60;
            
            const timeString = [
                hours.toString().padStart(2, '0'),
                minutes.toString().padStart(2, '0'),
                seconds.toString().padStart(2, '0')
            ].join(':');
            
            document.getElementById('game-time').textContent = timeString;
        }
        
        // New game button
        document.getElementById('new-game').addEventListener('click', () => {
            initBoard();
            updateStatus("New game started!");
        });
        
        // Flip board button
        document.getElementById('flip-board').addEventListener('click', () => {
            boardFlipped = !boardFlipped;
            renderBoard();
        });
        
        // Undo move button
        document.getElementById('undo-move').addEventListener('click', undoMove);
        
        // Play vs Human button
        document.getElementById('play-human').addEventListener('click', () => {
            vsComputer = false;
            document.getElementById('play-human').classList.add('active');
            document.getElementById('play-computer').classList.remove('active');
            initBoard();
            updateStatus("New game started - playing against human!");
        });
        
        // Play vs Computer button
        document.getElementById('play-computer').addEventListener('click', () => {
            vsComputer = true;
            document.getElementById('play-computer').classList.add('active');
            document.getElementById('play-human').classList.remove('active');
            initBoard();
            updateStatus("New game started - playing against computer!");
        });
        
        // Toggle computer color button
        document.getElementById('computer-color').addEventListener('click', () => {
            computerColor = computerColor === 'black' ? 'white' : 'black';
            document.getElementById('computer-color').textContent = `Computer: ${computerColor.charAt(0).toUpperCase() + computerColor.slice(1)}`;
            initBoard();
            updateStatus(`New game started - computer plays ${computerColor}!`);
        });
        
        // Initialize the game
        initBoard();
    </script>
</body>
</html>
